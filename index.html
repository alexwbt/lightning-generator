<canvas id="main-canvas"></canvas>

<style>
    * {
        margin: 0;
    }
</style>

<script>

    const canvas = window.document.getElementById('main-canvas');
    const ctx = canvas.getContext('2d');

    class Vec2 {
        constructor(x = 0, y = 0) {
            this.x = x;
            this.y = y;
        }
    }

    class Lightning {

        constructor(
            startPoint, endPoint, width,
            displacement, subdivision,
            branchChance, branchRad
        ) {
            this.length = Math.sqrt(
                Math.pow(startPoint.x - endPoint.x, 2),
                Math.pow(startPoint.y - endPoint.y, 2)
            );

            this.width = width;
            
            this.points = [startPoint, endPoint];
            this.points.length = 2;
            this.childBranch = [];

            this.displacement = displacement;
            this.subdivision = subdivision;

            this.branchChance = branchChance;
            this.branchRad = branchRad;

            this.generate();
            this.branch();
        }

        generate() {
            for (let i = 0; i < this.subdivision; i++) {

                const midPoints = []; // size = this.points.length - 1

                for (let j = 1; j < this.points.length; j++) {
                    const startPoint = this.points[j - 1];
                    const endPoint = this.points[j];
                    const midPoint = new Vec2(
                        (startPoint.x + endPoint.x) / 2,
                        (startPoint.y + endPoint.y) / 2
                    );

                    midPoint.x += (Math.random() - 0.5) * (this.length * this.displacement) * Math.pow(0.5, i);
                    midPoint.y += (Math.random() - 0.5) * (this.length * this.displacement) * Math.pow(0.5, i);

                    midPoints.push(midPoint);
                }

                const newPts = [];
                for (let j = 0; j < this.points.length - 1; j++) {
                    newPts.push(this.points[j]);
                    newPts.push(midPoints[j])
                }
                newPts.push(this.points[this.points.length - 1]);
                this.points = newPts;
            }
        }

        branch() {
            for (let i = 1; i < this.points.length; i++) {
                if (Math.random() < this.branchChance) {
                    const startPoint = this.points[i - 1];
                    const endPoint = this.points[i];

                    const dir = Math.atan2(
                        endPoint.y - startPoint.y,
                        endPoint.x - startPoint.x
                    ) + (Math.random() - 0.5) * this.branchRad;

                    const branchLength = this.length * this.displacement * Math.random()

                    const branchEndPoint = new Vec2(
                        startPoint.x + Math.cos(dir) * branchLength,
                        startPoint.y + Math.sin(dir) * branchLength
                    );

                    const branchSubdivision = Math.floor(Math.log(this.points.length * (branchLength / this.length)) / Math.log(2));


                    this.childBranch.push(new Lightning(
                        startPoint, branchEndPoint, this.width / 4,
                        this.displacement * 1.5, branchSubdivision,
                        this.branchChance, this.branchRad
                    ));
                }
            }
        }

        render() {
            ctx.strokeStyle = 'white';
            ctx.lineWidth = this.width;
            ctx.moveTo(this.points[0].x, this.points[0].y);
            for (const pt of this.points.slice(1)) {
                ctx.lineTo(pt.x, pt.y);
            }
            ctx.stroke();

            for (const branch of this.childBranch)
                branch.render();
        }

    }

    let lightning;

    setInterval(() => {
        lightning = new Lightning(
            new Vec2(), new Vec2(window.innerWidth, window.innerHeight), 10,
            0.3, 10,
            0.005, Math.PI * 0.5
        );
    }, 1000);

    const loop = () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        if (lightning) lightning.render();

        window.requestAnimationFrame(loop);
    };

    loop();

</script>