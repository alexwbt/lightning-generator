<canvas id="main-canvas"></canvas>

<style>
    * {
        margin: 0;
    }
</style>

<script>

    const canvas = window.document.getElementById('main-canvas');
    const ctx = canvas.getContext('2d');

    class Vec2 {
        constructor(x = 0, y = 0) {
            this.x = x;
            this.y = y;
        }
    }

    class Lightning {

        constructor(
            startPoint, endPoint,
            displacement, subdivision,
            branchChance, branchRad, branchLength
        ) {
            this.points = [startPoint, endPoint];
            this.pointCount = 2;
            this.childBranch = [];

            this.displacement = displacement;
            this.subdivision = subdivision;

            this.branchChance = branchChance;
            this.branchRad = branchRad;
            this.branchLength = branchLength;

            this.generate();
            this.branch();
        }

        generate() {
            for (let i = 0; i < this.subdivision; i++) {

                const midPoints = []; // size = this.pointCount - 1

                for (let j = 1; j < this.pointCount; j++) {
                    const startPoint = this.points[j - 1];
                    const endPoint = this.points[j];
                    const midPoint = new Vec2(
                        (startPoint.x + endPoint.x) / 2,
                        (startPoint.y + endPoint.y) / 2
                    );

                    midPoint.x += (Math.random() - 0.5) * this.displacement * Math.pow(0.5, i + 1);
                    midPoint.y += (Math.random() - 0.5) * this.displacement * Math.pow(0.5, i + 1);

                    midPoints.push(midPoint);
                }

                const newPts = [];
                for (let j = 0; j < this.pointCount - 1; j++) {
                    newPts.push(this.points[j]);
                    newPts.push(midPoints[j])
                }
                newPts.push(this.points[this.pointCount - 1]);
                this.points = newPts;
                this.pointCount = newPts.length;
            }
        }

        branch() {
            for (let i = 0; i < this.subdivision; i++) {
                for (let j = 1; j < this.pointCount; j++) {
                    if (Math.random() < this.branchChance) {
                        const startPoint = this.points[j - 1];
                        const endPoint = this.points[j];
                        const distance = Math.sqrt(
                            Math.pow(startPoint.x - endPoint.x, 2),
                            Math.pow(startPoint.y - endPoint.y, 2)
                        );

                        const dir = Math.atan2(
                            endPoint.y - startPoint.y,
                            endPoint.x - startPoint.x
                        ) + (Math.random() - 0.5) * this.branchRad;
                        
                        const branchEndPoint = new Vec2(
                            startPoint.x + Math.cos(dir) * this.branchLength,
                            startPoint.y + Math.sin(dir) * this.branchLength
                        );

                        this.childBranch.push(new Lightning(
                            startPoint, branchEndPoint,
                            this.displacement * 0.1, this.subdivision / 2,
                            this.branchChance, this.branchRad, distance
                        ));
                    }
                }
            }
        }

        render() {
            ctx.strokeStyle = 'white';
            ctx.moveTo(this.points[0].x, this.points[0].y);
            for (const pt of this.points.slice(1)) {
                ctx.lineTo(pt.x, pt.y);
            }
            ctx.stroke();

            for (const branch of this.childBranch)
                branch.render();
        }

    }

    let lightning;

    setInterval(() => {
        lightning = new Lightning(
            new Vec2(), new Vec2(window.innerWidth, window.innerHeight),
            500, 5,
            0.01, Math.PI * 0.3, 300
        );
    }, 1000);

    const loop = () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        if (lightning) lightning.render();

        window.requestAnimationFrame(loop);
    };

    loop();

</script>